using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using QPathFinder;
using UnityEngine.Assertions.Must;
using System;
using UnityEditor;

public class TestGraph : MonoBehaviour
{
    PathFinder PathFinder;
    public Mesh Mesh;


    int source = 0;
    int destination = 0;

    List<Vector3> path;
    // Start is called before the first frame update
    void Start()
    {
        PathFinder = gameObject.AddComponent<PathFinder>();
        PathFinder.graphData = GetGraph(Mesh);

        //PathFinder.graphData.ReGenerateIDs();

        source = PathFinder.graphData.nodes[2].autoGeneratedID;
        destination = PathFinder.graphData.nodes[985].autoGeneratedID;

        PathFinder.FindShortestPathOfNodes(source,destination,Execution.Asynchronously, OnPathFind);

    }

    GameObject go;
    LineRenderer lineRenderer;
    private void OnPathFind(List<Node> obj)
    {
        path = new List<Vector3>();
        for (int i = 0; i < obj.Count; i++)
        {
            path.Add(obj[i].Position);
        }

        if (go == null)
        {
            go = new GameObject();
            lineRenderer = go.AddComponent<LineRenderer>();
            lineRenderer.startWidth = 0.05f;
            lineRenderer.endWidth = 0.05f;

            lineRenderer.material = new Material(Shader.Find("Unlit/Color"));
            lineRenderer.material.color = Color.blue;
        }
        lineRenderer.positionCount = path.Count;
        lineRenderer.SetPositions(path.ToArray());

    }

    // Update is called once per frame
    void Update()
    {
        if (Input.GetKeyUp(KeyCode.A))
        {
            source = 1;
            Debug.Log("PathFinder.graphData.nodes: " + PathFinder.graphData.nodes.Count);
            Debug.Log("PathFinder.graphData.paths: " + PathFinder.graphData.paths.Count);
            destination = PathFinder.graphData.nodes[
                UnityEngine.Random.Range(0, PathFinder.graphData.nodes.Count)
                ].autoGeneratedID;
            Debug.Log(source + "___" + destination);
            PathFinder.FindShortestPathOfNodes(source,destination,Execution.Asynchronously, OnPathFind);

        }
    }

    GraphData GetGraph(Mesh mesh)
    {
        GraphData graphData = new GraphData();
        Vector3[] localVerts = mesh.vertices;

        int[] localTris = mesh.triangles;

        for (int i = 0, cnt = localVerts.Length; i < cnt; i++)
        {
            Node node = new Node(localVerts[i]);
            node.autoGeneratedID = i;
            graphData.nodes.Add(node);
            graphData.nodesSorted[node.autoGeneratedID] =node;
            Debug.Log("AAAAAAA: " + i + "__" + node.autoGeneratedID); ;
        }

        Debug.Log("graphData.nodesSorted.Count: "+graphData.nodesSorted.Count);

        Debug.Log(" localTris.Length: " + localTris.Length);
        int stride = 3;
        for (int i = 0,numTris = localTris.Length; i < numTris; i += stride)
        {
            Debug.Log(localTris[i + 0]+"__"+ localTris[i + 1]+"__"+ localTris[i + 2]);

            Node v1 = graphData.nodesSorted[localTris[i + 0]];
            Node v2 = graphData.nodesSorted[localTris[i + 1]];
            Node v3 = graphData.nodesSorted[localTris[i + 2]];

            Path path1 = new Path(v1.autoGeneratedID, v2.autoGeneratedID);


            Path path2 = new Path(v2.autoGeneratedID, v3.autoGeneratedID);
            Path path3 = new Path(v3.autoGeneratedID, v1.autoGeneratedID);

            if (graphData.GetPathBetween(v1, v2) == null)
            {
                graphData.paths.Add(path1);
                graphData.pathsSorted[i + 0] = path1;
            }
            else
            {
                Debug.Log("AlreadyContains: v1,v2");
            }
            if (graphData.GetPathBetween(v2, v3) == null)
            {
                graphData.paths.Add(path2);
                graphData.pathsSorted[i + 1] = path2;
            }
            else
            {
                Debug.Log("AlreadyContains: v2,v3");
            }
            if (graphData.GetPathBetween(v3, v1) == null)
            {
                graphData.paths.Add(path3);
                graphData.pathsSorted[i + 2] = path3;
            }
            else
            {
                Debug.Log("AlreadyContains: v3,v1");
            }
        }
        Debug.Log("graphData.paths: "+graphData.paths.Count);

        return graphData;
    }

    protected void OnDrawGizmos()
    {
        if (PathFinder == null) return;

        Gizmos.matrix = transform.localToWorldMatrix;

#if UNITY_EDITOR
        Handles.matrix = transform.localToWorldMatrix;
#endif

        for (int i = 0, n = PathFinder.graphData.nodes.Count; i < n; i++)
        {
            var node = PathFinder.graphData.nodes[i];
            Gizmos.color = ((i == source) || (i == destination)) ? Color.white : Color.red;
            Gizmos.DrawSphere(node.Position, 0.1f);
        }

        Gizmos.color = Color.black;

        PathFinder.graphData.paths.ForEach(e =>
        {
            var from= PathFinder.graphData.GetNode(e.IDOfA);
            var to = PathFinder.graphData.GetNode(e.IDOfB);
            Gizmos.DrawLine(from.Position, to.Position);
        });

        Gizmos.color = Color.green;

        if (path != null)
        {
            for (int i = 0, n = path.Count-1; i < n; i++)
            {
                var from = path[i];
                var to = path[i + 1];
                Gizmos.DrawLine(from, to);
            }
        }
    }
}

